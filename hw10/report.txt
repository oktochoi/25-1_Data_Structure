1. Insertion Sort (삽입 정렬)
개념: 현재 위치의 원소를 정렬된 부분과 비교하여 알맞은 위치에 삽입

시간 복잡도:

평균/최악: O(n²), 최선(이미 정렬된 경우): O(n)

공간 복잡도: O(1)

특징:

구현이 간단하고, 작은 데이터에 효율적

안정 정렬 (같은 값의 순서가 유지됨)

2. Quick Sort (퀵 정렬)
개념: 피벗을 기준으로 왼쪽은 작은 값, 오른쪽은 큰 값으로 분할 후 재귀 정렬

시간 복잡도:

평균: O(n log n), 최악(피벗이 한쪽 끝 선택): O(n²)

공간 복잡도: O(log n) (재귀 호출 스택)

특징:

내부 정렬

불안정 정렬

실제로 매우 빠름 (정렬 라이브러리에서 자주 사용)

3. Optimal Sorting Time (최적 정렬 시간)
정의: 비교 기반 정렬의 이론적 최선 시간은 O(n log n)

설명:

어떤 비교 기반 알고리즘도 최악의 경우 O(n log n)보다 빠를 수 없음

이 한계를 가지지 않는 정렬이 Radix Sort처럼 비교 기반이 아닌 정렬

4. Merge Sort (병합 정렬)
개념: 리스트를 반으로 나누고 정렬 후 병합

시간 복잡도: O(n log n)

공간 복잡도: O(n) (병합을 위한 추가 배열 필요)

특징:

안정 정렬

재귀 구조

큰 데이터를 정렬할 때 예측 가능

외부 정렬(External sort)에 자주 사용됨

5. Heap Sort (힙 정렬)
개념: 힙(Heap) 자료구조를 사용하여 최대값 또는 최소값부터 정렬

시간 복잡도: O(n log n)

공간 복잡도: O(1)

특징:

불안정 정렬

빠르고 공간 효율적

우선순위 큐 구현에도 사용됨

6. Radix Sort (기수 정렬)
개념: 자릿수(혹은 키)를 기준으로 정렬 (LSD 또는 MSD 방식)

시간 복잡도: O(nk) (k는 자릿수)

공간 복잡도: O(n + k)

특징:

비교 기반이 아님

정수, 문자열 등 자릿수 기반 정렬에 적합

안정 정렬

O(n log n) 비교 기반 한계를 넘는 경우 존재

7. External Sorting (외부 정렬)
개념: 메모리에 올릴 수 없는 큰 데이터를 디스크에서 일부만 불러와 정렬

방식:

데이터를 나누어 정렬한 뒤 merge

Merge Sort를 기반으로 하는 경우가 많음

특징:

빅데이터, 데이터베이스 등에서 중요

디스크 접근 최소화가 핵심

